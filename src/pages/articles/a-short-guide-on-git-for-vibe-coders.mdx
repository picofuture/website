import { ArticleLayout } from '@/components/ArticleLayout'
import {BLOG_AUTHOR_ANFAL} from "@/lib/sharedConsts"
import BlogImage from "@/components/blog-components/BlogImage";
import BlogYoutubeVideoEmbed from "@/components/blog-components/BlogYoutubeVideoEmbed";

export const meta = {
  author: BLOG_AUTHOR_ANFAL,
  date: '2025-05-21',
  title: 'A Short Guide on Git for Vibe Coders',
  description: 'A short guide on Git for Vibe Coders',
  draft: false,
  slug: 'a-short-guide-on-git-for-vibe-coders',
  image: "blog/2025-05-21-a-short-guide-on-git-for-vibe-coders/cover.png"
}

export default (props) => <ArticleLayout meta={meta} {...props} />

<BlogImage src="blog/2025-05-21-a-short-guide-on-git-for-vibe-coders/cover.png" alt="Git for Vibe Coders" />

## Before we begin
This isn't a hands-on git tutorial. If you want commands, go read <a href="https://git-scm.com/docs/gittutorial" target="_blank">Git's official documentation</a> or try <a href="https://learngitbranching.js.org/" target="_blank">Learn Git Branching</a>.

This guide is for people who build by feel. You're not memorizing flags or syntax; you're here to understand **how git works** or what it even is. You want to understand how it will help you protect your projects so they don't get nuked when your editor crashes.

---

## When do you actually need Git?
If you're coding inside <a href="https://bolt.new" target="_blank">Bolt</a>, <a href="https://lovable.dev" target="_blank">Lovable</a>, or <a href="https://replit.com" target="_blank">Replit</a> - you don't. Those services have built-in automatic version control.

You only need Git when you graduate to <a href="https://cursor.com" target="_blank">Cursor</a> or <a href="https://windsurf.com" target="_blank">Windsurf</a>. That's when the training wheels come off.

You don't need to memorize commands. The AI will run them for you. What you need to understand is **why** and **when** to use Git.

---

## A bit about Git

### What is Git?
Git is a **distributed version control system** designed to track changes in code over time. It's the current industry standard. Useful for code. Useful for any evolving project.

### Why It Matters
- **Protects Your Work** - You can undo mistakes, revert to previous versions, and experiment safely.
- **Enables Collaboration** - Multiple people can work on the same project without stepping on each other.
- **Documents Progress** - Every change has a timestamp, a message, and an author. Like a project logbook.

### Core Concepts
- **Repository**: Your project folder tracked by Git.
- **Commit**: A snapshot of your changes.
- **Branch**: A parallel version of your codebase to test ideas.
- **Merge**: Combining branches.
- **Remote**: The online version of your repo (e.g., GitHub).
- **Push/Pull**: Sending or receiving changes between local and remote.

### What is GitHub?
GitHub is a **remote** that stores your Git history. Like a cloud backup.

### Key Difference
- **Git** is local. Think of it as your time machine.
- **GitHub** is remote. Think of it as your safety deposit box.

---

## What actually happens when you "init Git"
You walk into a folder, ask your AI “is git initialized here?”, and if it isn't, you say “start it.”

This creates a hidden `.git` folder and sets your current branch to `main`. That's the default timeline of your project.

<BlogImage src="blog/2025-05-21-a-short-guide-on-git-for-vibe-coders/vibe-git-init-1.png" alt="Git Init" />

---

## Untracked → Staged → Committed
This is the lifecycle of a file in Git.

1. **Untracked** – Git doesn't know this file exists.
2. **Staged** – You've selected it for the next snapshot.
3. **Committed** – The snapshot is saved.

<BlogImage src="blog/2025-05-21-a-short-guide-on-git-for-vibe-coders/vibe-git-tracking.png" alt="Git tracking" />

Modified files go through the same process. Git doesn't care if it's new or changed - it just tracks states.

---

## GitHub is just your offsite backup
Create a GitHub repo. Copy the HTTPS link. Set that link as your remote.

Now you can push your local snapshots to the cloud.

<BlogImage src="blog/2025-05-21-a-short-guide-on-git-for-vibe-coders/vibe-github.png" alt="Github setup" />

---

## The power of branching
This is where Git becomes a cheat code.

You don't need to commit to one timeline. You can branch off, explore, return.

Use branches when:
- You're building a risky feature
- You need to fix an issue on the live environment
- You want to test ideas in isolation

<BlogImage src="blog/2025-05-21-a-short-guide-on-git-for-vibe-coders/vib-branching.png" alt="Git branching" />

---

## Merge conflicts: when timelines collide
Let's say two branches touch the same line. Git won't guess.

When you merge, it flags the conflict and asks you to choose:
- Keep A
- Keep B
- Combine both

It's not magic. It's merge arbitration.

<BlogImage src="blog/2025-05-21-a-short-guide-on-git-for-vibe-coders/conflict.png" alt="Merge conflict" />

---

## What matters is **why**, not **how**
You don't need to memorize anything.

Just understand:
- Git is for **saving states**
- GitHub is for **backups**
- Branches let you **explore freely**
- Conflicts are just **decisions to make**

<BlogImage src="blog/2025-05-21-a-short-guide-on-git-for-vibe-coders/final-thoughts.png" alt="Final thoughts" />

Now go break things. You've got a time machine.

Until next time, happy vibe coding.
