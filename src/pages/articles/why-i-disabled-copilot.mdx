import { ArticleLayout } from '@/components/ArticleLayout'
import {BLOG_AUTHOR_ANFAL} from "@/lib/sharedConsts"
import BlogImage from "@/components/blog-components/BlogImage";

export const meta = {
    author: BLOG_AUTHOR_ANFAL,
    date: '2024-09-29',
    title: 'Why I have disabled Github copilot',
    description: 'An in-depth look at why I have disabled Github copilot',
    slug: 'why-i-disabled-copilot',
    image: "blog/2024-09-29-why-i-have-disabled-copilot/no-copilot.png"
}

export default (props) => <ArticleLayout meta={meta} {...props} />

<BlogImage src='blog/2024-09-29-why-i-have-disabled-copilot/no-copilot.png' alt="Disabled Github copilot" />

## Why I Partially Disabled Copilot
I have to confess. I have not disabled the copilot completely. I have reassigned it to a specific keybinding in my editor. This will allow me to still leverage the copilot, but I will deliberately choose to use it instead of getting its automatic suggestions all the time.

## Why Did I Do It?
I have been using Copilot for over a year now. Don't get me wrong; I recognize its utility. It has helped me write code faster and saved me a lot of time.

But I have noticed that it has made me lazy. I have stopped thinking deeply about the code I am writing. I know what's been written, and I understand the logic behind it, but if you have tried writing code, you will understand that every keystroke matters.
As a developer, it is my job to think deeply and make deliberate choices when writing code.

Every excellent developer I’ve met during my professional experience has one thing in common: They think deeply about the code they write and understand what it does.
It's like comparing a developer who only learned one framework of a specific language to a developer who knows the language inside out and can create a complicated and scalable system from scratch.

The latter is more likely to be a stronger developer. I would compare this to the difference between a technician and an engineer. There is nothing wrong with being a technician, and if that's what you want, go for it. But I see myself as an engineer, not just a technician.

I want to be the latter. If Copilot does everything for me, I will never learn anything new, and my abilities will stagnate and deteriorate over time. It's a well-known phenomenon in cognitive science that humans tend to forget skills or knowledge they don't regularly use, often called <a href="https://en.wikipedia.org/wiki/Decay_theory" target="blank">"decay theory."</a>
Just as muscles will weaken without exercise, cognitive skills like analytical and algorithmic thinking will require continuous practice to stay sharp.
Regular reinforcement will be necessary to prevent these abilities from fading and to maintain high-level performance.

Furthermore, I am looking to massively upscale my engineering skills, including creating distributed systems, system design, and behavioral skills.
One essential skill for becoming a better developer is the ability to solve problems by putting algorithms on a whiteboard, without relying on type checks, error lookups, or intellisense. It's pure, deep analytical thinking with a pinch of dry-running capability.

Additionally, I want to contribute to complex open-source projects that don’t rely on frameworks but serve as the source of truth for many other projects.
These types of contributions require a deep understanding of core principles, where it’s incredibly hard to rely on Copilot to provide meaningful assistance.
For such complex systems, having a solid command over the language and its intricacies is crucial.

Why it's essential to learn how to put an algorithm on a whiteboard is an entirely different topic, so I'll digress from that for now.
But understand that my goal is to have mastery over a programming language, much like my native language. I should be able to use it with extreme precision, without depending on a "tutor/Copilot" to correct me or give me hints every few seconds (I’ve chosen Python, by the way).

## Why Not Disable Copilot Entirely?
I have considered disabling Copilot entirely, but I’ve decided to keep it around. It's an excellent tool for repetitive tasks like creating data—it’s an automation tool, after all.
However, beyond that, Copilot can also help you implement better algorithms by providing suggestions. But it’s your responsibility to fully absorb those algorithms, evaluate them, and ensure they align with your business logic.
Think of Copilot as a loaded gun: it’s powerful and can save time, but it must be used efficiently and with care.

My approach is to use Copilot deliberately, without letting it take over my thought process. The goal is to review the suggestions, understand why they’re being proposed, and then implement each line of code myself.

This way, I can leverage Copilot’s capabilities while keeping my analytical thinking sharp. Each time I use it, it will be a deliberate, conscious choice.

## Advice For Other Developers
It's perfectly fine to use automation tools like Copilot—after all, they can help speed up the learning process and save time on repetitive tasks.
However, it's essential to first focus on building a solid foundation in coding. Understanding the core principles and algorithms behind your work is critical to long-term success as a developer.
Copilot should augment your work, not overtake it. Use it as a tool to enhance your understanding, but ensure that you are actively learning and thinking critically about the code you write, so you don’t become overly reliant on it.

## Closing Thoughts
In the end, it's about staying in control. Copilot is an incredible tool, but it’s up to us to decide how we use it. Automation should enhance our abilities, not replace the critical thinking that makes us great developers.